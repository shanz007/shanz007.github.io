[
  
  {
    "title": "Code Quality Series #1 ‚Äî Avoiding Redundant Conditionals",
    "url": "/blog/posts/code-quality-series-1-avoiding-redundant-conditionals/",
    "categories": "Software Engineering, Code Quality",
    "tags": "java, clean-code, best-practices, static-analysis",
    "date": "2020-02-12 15:12:12 +0200",
    "content": "Introduction  Writing clean and maintainable code is not just about making it work, it‚Äôs about making it understandable, scalable, and error-resistant. One common issue that developers often overlook is the presence of redundant conditionals. These add unnecessary complexity, make code harder to read, and sometimes even mask bugs.  In this post, we‚Äôll explore through an example and show how simplifying conditionals leads to clearer and more maintainable code.     üí° Available since Java 16 and widely adopted in production codebases using Java 17+ onwards. It‚Äôs clean and eliminates redundant casting ((String) object). üí° In production, CI/CD pipelines often integrate static analysis tools (SonarQube, Checkstyle, PMD), which can automatically catch redundant conditionals. However, understanding and handling them beforehand is always better.   What are redundant conditionals &amp; How can we spot them?  Consider the following method:  public static boolean isNullable(Object object) {     if (object != null) {         if (object instanceof String) {             String strVal = (String) object;             if (strVal.trim().equals(\"\") ||                 strVal.trim().equals(\"null\")) {                 return true;             } else {                 return false;             }         }     }     return true; }   What‚Äôs wrong here?  At first glance, this may look like a normal method, but it carries hidden costs. Do you know why?     Nested conditionals ‚Äì too many if blocks make the logic hard to follow.   Redundancy ‚Äì returning true or false inside an if/else is unnecessary when the condition itself already evaluates to a boolean.   Readability ‚Äì the method intent (check if string is null-like) is buried under boilerplate.   How to avoid them ?  Depending on the Java version your codebase is based on, refactoring may differ.  ‚úÖ on Java (17+ with Pattern Matching)  public static boolean isNullable(Object object) {     if (object instanceof String strVal) {         return strVal.trim().isEmpty() || strVal.trim().equals(\"null\");     }     return object == null; }   As you may see it is cleaner, uses pattern matching for instanceof (Java 16+), and directly returns boolean expressions.  ‚úÖ More Concise with Objects + Pattern Matching  If you aim for maximum readability, especially in modern codebases that rely on streams and functional style we can further refactor above  public static boolean isNullable(Object object) {   return Objects.isNull(object) ||         (object instanceof String str &amp;&amp; (str.isBlank() || \"null\".equals(str))); }   ‚úÖ For Legacy-Friendly (Java 8/11 Compatible)  public static boolean isNullable(Object object) {     if (object instanceof String) {         String strVal = (String) object;         return strVal.trim().isEmpty() || strVal.trim().equals(\"null\");     }     return object == null; }   Although it is slightly verbose still common in enterprise projects.  What are the benifits?     Improves readability by removing unnecessary nesting.   Avoids redundancy in returning booleans.   Complies with static analysis tools (SonarQube, Checkstyle, PMD).   Supports maintainability by making intent clear.      ‚úçÔ∏è This updated post is part of my ‚ÄúCode Quality‚Äù series, where I share practical examples and industry best practices from my experience over the years, and the original base article can also be found on Medium."
  }
  
]

